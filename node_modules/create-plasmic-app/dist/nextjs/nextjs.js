"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.nextjsStrategy = void 0;
const fs_1 = require("fs");
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const cmd_utils_1 = require("../utils/cmd-utils");
const codegen_1 = require("../utils/codegen");
const file_utils_1 = require("../utils/file-utils");
const lang_utils_1 = require("../utils/lang-utils");
const npm_utils_1 = require("../utils/npm-utils");
const catchall_page_1 = require("./templates/app-loader/catchall-page");
const plasmic_host_1 = require("./templates/app-loader/plasmic-host");
const plasmic_init_1 = require("./templates/app-loader/plasmic-init");
const plasmic_init_client_1 = require("./templates/app-loader/plasmic-init-client");
const app_1 = require("./templates/pages-codegen/app");
const plasmic_host_2 = require("./templates/pages-codegen/plasmic-host");
const catchall_page_2 = require("./templates/pages-loader/catchall-page");
const plasmic_host_3 = require("./templates/pages-loader/plasmic-host");
const plasmic_init_2 = require("./templates/pages-loader/plasmic-init");
exports.nextjsStrategy = {
    create: (args) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        const { projectPath, template, jsOrTs, platformOptions } = args;
        const typescriptArg = `--${jsOrTs}`;
        const experimentalAppArg = ((_a = platformOptions.nextjs) === null || _a === void 0 ? void 0 : _a.appDir)
            ? "--app"
            : "--no-app";
        const templateArg = template ? ` --template ${template}` : "";
        const createCommand = `npx create-next-app@latest ${projectPath} ${typescriptArg} ${experimentalAppArg} ${templateArg}` +
            ` --eslint --no-src-dir  --import-alias "@/*" --no-tailwind`;
        // Default Next.js starter already supports Typescript
        // See where we `touch tsconfig.json` later on
        yield (0, cmd_utils_1.spawnOrFail)(createCommand);
    }),
    installDeps: ({ scheme, projectPath }) => __awaiter(void 0, void 0, void 0, function* () {
        if (scheme === "loader") {
            return yield (0, npm_utils_1.installUpgrade)("@plasmicapp/loader-nextjs", {
                workingDir: projectPath,
            });
        }
        else {
            return yield (0, codegen_1.installCodegenDeps)({ projectPath });
        }
    }),
    overwriteConfig: (args) => __awaiter(void 0, void 0, void 0, function* () {
        const { projectPath, scheme } = args;
        const nextjsConfigFile = path_1.default.join(projectPath, "next.config.mjs");
        if (scheme === "codegen") {
            yield fs_1.promises.writeFile(nextjsConfigFile, `
/** @type {import('next').NextConfig} */
const nextConfig = {
  eslint: {
    ignoreDuringBuilds: true,
  },
  trailingSlash: true,
  reactStrictMode: true,
};

export default nextConfig;`);
        }
    }),
    generateFiles: (args) => {
        var _a;
        if ((_a = args.platformOptions.nextjs) === null || _a === void 0 ? void 0 : _a.appDir) {
            return generateFilesAppDir(args);
        }
        else {
            return generateFilesPagesDir(args);
        }
    },
    build: (args) => __awaiter(void 0, void 0, void 0, function* () {
        const { npmRunCmd, projectPath } = args;
        yield (0, cmd_utils_1.spawnOrFail)(`${npmRunCmd} build`, projectPath);
    }),
};
function generateFilesAppDir(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const { projectPath, jsOrTs, projectId, projectApiToken } = args;
        // Delete existing pages
        (0, file_utils_1.deleteGlob)(path_1.default.join(projectPath, "app", "page.*"));
        // ./plasmic-init.ts
        yield fs_1.promises.writeFile(path_1.default.join(projectPath, `plasmic-init.${jsOrTs}`), (0, plasmic_init_1.makePlasmicInit_app_loader)(projectId, (0, lang_utils_1.ensure)(projectApiToken)));
        // ./plasmic-init-client.ts
        yield fs_1.promises.writeFile(path_1.default.join(projectPath, `plasmic-init-client.${jsOrTs}x`), (0, plasmic_init_client_1.makePlasmicInitClient_app_loader)(jsOrTs));
        // ./app/plasmic-host/page.tsx
        yield fs_1.promises.mkdir(path_1.default.join(projectPath, "app", "plasmic-host"));
        yield fs_1.promises.writeFile(path_1.default.join(projectPath, "app", "plasmic-host", `page.${jsOrTs}x`), (0, plasmic_host_1.makePlasmicHostPage_app_loader)());
        // ./app/[[...catchall]]/page.tsx
        yield fs_1.promises.mkdir(path_1.default.join(projectPath, "app", "[[...catchall]]"));
        yield fs_1.promises.writeFile(path_1.default.join(projectPath, "app", "[[...catchall]]", `page.${jsOrTs}x`), (0, catchall_page_1.makeCatchallPage_app_loader)(jsOrTs));
    });
}
function generateFilesPagesDir(args) {
    return __awaiter(this, void 0, void 0, function* () {
        const { projectPath, scheme, jsOrTs, projectId, projectApiToken } = args;
        // Delete existing pages
        (0, file_utils_1.deleteGlob)(path_1.default.join(projectPath, "pages", "*.*"));
        if (scheme === "loader") {
            // ./plasmic-init.ts
            yield fs_1.promises.writeFile(path_1.default.join(projectPath, `plasmic-init.${jsOrTs}`), (0, plasmic_init_2.makePlasmicInit_pages_loader)(projectId, (0, lang_utils_1.ensure)(projectApiToken)));
            // ./pages/plasmic-host.tsx
            yield fs_1.promises.writeFile(path_1.default.join(projectPath, "pages", `plasmic-host.${jsOrTs}x`), (0, plasmic_host_3.makePlasmicHostPage_pages_loader)());
            // ./pages/[[...catchall]].tsx
            yield fs_1.promises.writeFile(path_1.default.join(projectPath, "pages", `[[...catchall]].${jsOrTs}x`), (0, catchall_page_2.makeCatchallPage_pages_loader)(jsOrTs));
        }
        else {
            // ./pages/_app.tsx
            yield fs_1.promises.writeFile(path_1.default.join(projectPath, "pages", `_app.${jsOrTs}x`), (0, app_1.makeCustomApp_pages_codegen)(jsOrTs));
            // ./pages/plasmic-host.tsx
            yield fs_1.promises.writeFile(path_1.default.join(projectPath, "pages", `plasmic-host.${jsOrTs}x`), (0, plasmic_host_2.makePlasmicHostPage_pages_codegen)());
            // This should generate
            // ./plasmic.json
            // ./pages/index.tsx
            // ./components/plasmic/**
            yield (0, codegen_1.runCodegenSync)({
                projectId,
                projectApiToken,
                projectPath,
            });
            // Make an index page if the project didn't have one.
            const config = yield (0, file_utils_1.getPlasmicConfig)(projectPath, "nextjs", scheme);
            const plasmicFiles = lodash_1.default.map(lodash_1.default.flatMap(config.projects, (p) => p.components), (c) => c.importSpec.modulePath);
            if (!plasmicFiles.find((f) => f.includes("/index."))) {
                yield fs_1.promises.writeFile(path_1.default.join(projectPath, "pages", `index.${jsOrTs}x`), (0, file_utils_1.generateWelcomePage)(config, "nextjs"));
            }
        }
    });
}
