"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.gatsbyStrategy = exports.GATSBY_TEMPLATES = void 0;
const fs_1 = require("fs");
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const readline = __importStar(require("readline"));
const cmd_utils_1 = require("../utils/cmd-utils");
const codegen_1 = require("../utils/codegen");
const file_utils_1 = require("../utils/file-utils");
const lang_utils_1 = require("../utils/lang-utils");
const npm_utils_1 = require("../utils/npm-utils");
const template_1 = require("./template");
exports.GATSBY_TEMPLATES = {
    js: `https://github.com/gatsbyjs/gatsby-starter-minimal.git`,
    ts: `https://github.com/gatsbyjs/gatsby-starter-minimal-ts.git`,
};
exports.gatsbyStrategy = {
    create: (args) => __awaiter(void 0, void 0, void 0, function* () {
        const { projectPath, template, jsOrTs } = args;
        if (template) {
            console.log(`Warning: Ignoring template '${template}' (argument is not supported by Gatsby).`);
        }
        const gatsbyTemplate = exports.GATSBY_TEMPLATES[jsOrTs];
        const createCommand = `git clone ${gatsbyTemplate} ${projectPath} --recursive --depth 1 --quiet`;
        yield (0, cmd_utils_1.spawnOrFail)(`${createCommand}`);
        // Remove .git and LICENSE so that we don't generate linked outputs
        yield (0, cmd_utils_1.spawnOrFail)(`rm -rf ${projectPath}/.git`);
        yield (0, cmd_utils_1.spawnOrFail)(`rm -rf ${projectPath}/LICENSE`);
    }),
    installDeps: ({ projectPath, scheme, jsOrTs }) => __awaiter(void 0, void 0, void 0, function* () {
        const installedHelmet = yield (0, npm_utils_1.installUpgrade)("react-helmet", {
            workingDir: projectPath,
        });
        const installedHelmetTypes = jsOrTs === "js" ||
            (yield (0, npm_utils_1.installUpgrade)("@types/react-helmet", {
                workingDir: projectPath,
                dev: true,
            }));
        const installedHelmetPlugin = yield (0, npm_utils_1.installUpgrade)("gatsby-plugin-react-helmet", {
            workingDir: projectPath,
        });
        if (!installedHelmet || !installedHelmetPlugin || !installedHelmetTypes) {
            return false;
        }
        if (scheme === "loader") {
            return yield (0, npm_utils_1.installUpgrade)("@plasmicapp/loader-gatsby", {
                workingDir: projectPath,
            });
        }
        else {
            return yield (0, codegen_1.installCodegenDeps)({ projectPath });
        }
    }),
    overwriteConfig: (args) => __awaiter(void 0, void 0, void 0, function* () {
        var _a, e_1, _b, _c;
        const { projectId, projectPath, projectApiToken, jsOrTs, scheme } = args;
        const packageName = path_1.default.basename(projectPath);
        // Update package.json: adding name and description, removing license and author
        const packageJsonPath = path_1.default.join(projectPath, "package.json");
        const packageJson = yield fs_1.promises.readFile(packageJsonPath, "utf8");
        const packageJsonObject = JSON.parse(packageJson);
        packageJsonObject.name = packageName;
        packageJsonObject.description = `Plasmic app for ${projectId}`;
        delete packageJsonObject.license;
        delete packageJsonObject.author;
        yield fs_1.promises.writeFile(packageJsonPath, JSON.stringify(packageJsonObject, null, 2));
        if (scheme === "loader") {
            // create-gatsby will create a default gatsby-config that we need to modify
            const gatsbyConfigFile = path_1.default.join(projectPath, `gatsby-config.${jsOrTs}`);
            const rl = readline.createInterface({
                input: (0, fs_1.createReadStream)(gatsbyConfigFile),
                crlfDelay: Infinity,
            });
            // Typescript doesn't accept require.resolve
            // https://www.gatsbyjs.com/docs/how-to/custom-configuration/typescript/#requireresolve
            let result = (0, file_utils_1.ifTs)(jsOrTs, `import path from "path";\n`);
            const pluginConfig = (0, template_1.GATSBY_PLUGIN_CONFIG)(projectId, (0, lang_utils_1.ensure)(projectApiToken), jsOrTs);
            try {
                for (var _d = true, rl_1 = __asyncValues(rl), rl_1_1; rl_1_1 = yield rl_1.next(), _a = rl_1_1.done, !_a; _d = true) {
                    _c = rl_1_1.value;
                    _d = false;
                    const line = _c;
                    if (line.includes("plugins: []")) {
                        result += "  plugins: [" + pluginConfig + "]\n";
                    }
                    else if (line.includes("plugins: [")) {
                        result += line + pluginConfig + "\n";
                    }
                    else {
                        result += line + "\n";
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = rl_1.return)) yield _b.call(rl_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            yield fs_1.promises.writeFile(gatsbyConfigFile, result);
        }
    }),
    generateFiles: (args) => __awaiter(void 0, void 0, void 0, function* () {
        // in gatsby we can delete all existing pages/components, since all pages are going
        // to be handled by templates/defaultPlasmicPage
        const { projectId, projectApiToken, projectPath, jsOrTs, scheme } = args;
        (0, file_utils_1.deleteGlob)(path_1.default.join(projectPath, "src/@(pages|components|templates)/*.*"));
        // Create a very basic 404 page - `gatsby build` fails without it.
        yield fs_1.promises.writeFile(path_1.default.join(projectPath, `src/pages/404.${jsOrTs}`), template_1.GATSBY_404);
        // Add plasmic-host page
        yield fs_1.promises.writeFile(path_1.default.join(projectPath, `src/pages/plasmic-host.${jsOrTs}x`), (0, template_1.makeGatsbyHostPage)({
            jsOrTs,
            scheme,
        }));
        // Start with an empty gatsby-node
        yield fs_1.promises.writeFile(path_1.default.join(projectPath, `gatsby-node.${jsOrTs}`), "");
        // Updates `gatsby-ssr` to include script tag for preamble
        yield fs_1.promises.writeFile(path_1.default.join(projectPath, `gatsby-ssr.${jsOrTs}x`), template_1.GATSBY_SSR_CONFIG);
        if (scheme === "loader") {
            yield fs_1.promises.writeFile(path_1.default.join(projectPath, `src/plasmic-init.${jsOrTs}`), (0, template_1.makeGatsbyPlasmicInit)(jsOrTs));
            const templatesFolder = path_1.default.join(projectPath, "src/templates");
            if (!(0, fs_1.existsSync)(templatesFolder)) {
                yield fs_1.promises.mkdir(templatesFolder);
            }
            const defaultPagePath = path_1.default.join(templatesFolder, `defaultPlasmicPage.${jsOrTs}x`);
            yield fs_1.promises.writeFile(defaultPagePath, (0, template_1.makeGatsbyDefaultPage)(jsOrTs));
        }
        else {
            yield (0, codegen_1.runCodegenSync)({
                projectId,
                projectApiToken,
                projectPath,
            });
            // Special case: remove all Gatsby components (due to conflicting file names)
            const config = yield (0, file_utils_1.getPlasmicConfig)(projectPath, "gatsby", scheme);
            const plasmicFiles = lodash_1.default.map(lodash_1.default.flatMap(config.projects, (p) => p.components), (c) => c.importSpec.modulePath);
            (0, file_utils_1.deleteGlob)(path_1.default.join(projectPath, "src/@(pages|components)/*.*"), [
                // Files to ignore
                ...plasmicFiles.map((f) => path_1.default.basename(f)),
            ]);
            // Create a very basic 404 page - `gatsby build` fails without it.
            // We've deleted the components that the default 404 page depended
            // on, so
            yield fs_1.promises.writeFile(path_1.default.join(projectPath, `src/pages/404.${jsOrTs}x`), template_1.GATSBY_404);
            // Make an index page if the project didn't have one.
            if (!plasmicFiles.find((f) => f.includes("/index."))) {
                yield fs_1.promises.writeFile(path_1.default.join(projectPath, `src/pages/index.${jsOrTs}x`), (0, file_utils_1.generateWelcomePage)(config, "gatsby"));
            }
            // Overwrite the wrapper files to wrap PlasmicRootProvider
            const wrapperContent = (0, template_1.wrapAppRootForCodegen)();
            const browserFilePath = path_1.default.join(projectPath, `gatsby-browser.${jsOrTs}x`);
            yield fs_1.promises.writeFile(browserFilePath, wrapperContent);
            const ssrFilePath = path_1.default.join(projectPath, `gatsby-ssr.${jsOrTs}x`);
            yield fs_1.promises.writeFile(ssrFilePath, wrapperContent);
        }
    }),
    build: (args) => __awaiter(void 0, void 0, void 0, function* () {
        const { npmRunCmd, projectPath } = args;
        // A recurrent problem is `Something went wrong installing the "sharp" module`
        // https://github.com/gatsbyjs/gatsby/issues/20957
        // This may be a local problem for each person, but maybe we can try to handle it
        // here
        yield (0, cmd_utils_1.spawnOrFail)(`${npmRunCmd} build`, projectPath);
    }),
};
