"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = __importDefault(require("lodash"));
const lang_utils_1 = require("../utils/lang-utils");
const semver = __importStar(require("../utils/semver"));
const api = jest.genMockFromModule("../api");
/**
 * Store a simplified data model for use with testing
 */
// Keyed by (projectId, version)
const PROJECTS = [];
function clear() {
    while (PROJECTS.length > 0) {
        PROJECTS.shift();
    }
}
function mockProjectToProjectVersionMeta(mock, componentIdOrNames) {
    return Object.assign(Object.assign({}, mock), { componentIds: mock.components
            .filter((c) => !componentIdOrNames ||
            componentIdOrNames.includes(c.name) ||
            componentIdOrNames.includes(c.id))
            .map((c) => c.id) });
}
/**
 * Call this in test to setup the data model
 * @param id componentId
 * @param comp MockComponent
 */
function addMockProject(proj) {
    const projectId = proj.projectId;
    const version = proj.version;
    // Populate projectId and version into each component
    // will be useful when reading / writing components to files
    proj.components = proj.components.map((c) => {
        return Object.assign(Object.assign({}, c), { projectId,
            version });
    });
    const existing = getMockProject(projectId, version);
    if (!existing) {
        PROJECTS.push(proj);
    }
    else {
        existing.components = proj.components;
        existing.dependencies = proj.dependencies;
    }
}
/**
 * Used to interpret data that's stored in the "codegen" files from the Mock server
 * @param data
 */
function stringToMockComponent(data) {
    if (!data) {
        return;
    }
    const withoutComments = data.startsWith("//") ? data.slice(2) : data;
    const cleaned = withoutComments.trim();
    return JSON.parse(cleaned);
}
/**
 * Used to write mock data into files for testing.
 * Useful to see what version was written
 * Need to prefix with a comment to satisfy the parser used in `fixAllImports`
 * @param component
 */
function mockComponentToString(component) {
    return "// " + JSON.stringify(component);
}
function getMockProject(projectId, version) {
    return PROJECTS.find((m) => m.projectId === projectId && m.version === version);
}
/**
 * Only fetch top-level components that match the projectId (optionally also componentIdOrNames + version)
 * Does not crawl the dependency tree
 * @param projectId
 * @param componentIdOrNames
 * @param versionRange
 */
function getMockComponents(projectId, version, componentIdOrNames) {
    const project = getMockProject(projectId, version);
    return !project
        ? []
        : project.components.filter((c) => !componentIdOrNames ||
            componentIdOrNames.includes(c.id) ||
            componentIdOrNames.includes(c.name));
}
function genFilename(base, suffix) {
    return "Plasmic" + base + "." + suffix;
}
function genComponentBundle(component) {
    return {
        renderModule: mockComponentToString(component),
        skeletonModule: mockComponentToString(component),
        cssRules: `theClass {color: blue;}`,
        renderModuleFileName: genFilename(component.name, "tsx"),
        skeletonModuleFileName: component.name + ".tsx",
        cssFileName: genFilename(component.name, "css"),
        componentName: component.name,
        id: component.id,
        scheme: "blackbox",
        nameInIdToUuid: [],
        isPage: false,
    };
}
function genEmptyStyleTokensMap() {
    return {
        props: [],
        global: {
            meta: {
                source: "plasmic.app",
            },
        },
    };
}
function genProjectMetaBundle(projectId) {
    return {
        projectId,
        projectName: projectId,
        cssFileName: genFilename(projectId, "css"),
        cssRules: `theClass {color: green;}`,
        jsBundleThemes: [],
    };
}
function* getDeps(projects) {
    const queue = [...projects];
    while (queue.length > 0) {
        const curr = lang_utils_1.ensure(queue.shift());
        for (const [projectId, version] of lodash_1.default.toPairs(curr.dependencies)) {
            const mockProject = lang_utils_1.ensure(getMockProject(projectId, version));
            const projectMeta = mockProjectToProjectVersionMeta(mockProject);
            yield projectMeta;
            queue.push(projectMeta);
        }
    }
}
class PlasmicApi {
    constructor(auth) {
        this.auth = auth;
        this.lastProjectIdsAndTokens = [];
    }
    genStyleConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            const result = {
                defaultStyleCssFileName: genFilename("default", "css"),
                defaultStyleCssRules: `theClass {color: red;}`,
            };
            return result;
        });
    }
    resolveSync(projects, recursive) {
        return __awaiter(this, void 0, void 0, function* () {
            const results = {
                projects: [],
                dependencies: [],
                conflicts: [],
            };
            // Get top level projects
            projects.forEach((proj) => {
                const availableProjects = Array.from(PROJECTS.values()).filter((p) => p.projectId === proj.projectId);
                if (!((this.auth.user && this.auth.token) ||
                    availableProjects.every((p) => p.projectApiToken === proj.projectApiToken))) {
                    throw new Error("No user+token, and project API tokens don't match");
                }
                const availableVersions = availableProjects.map((p) => p.version);
                const version = semver.maxSatisfying(availableVersions, proj.versionRange);
                if (version) {
                    const mockProject = lang_utils_1.ensure(getMockProject(proj.projectId, version));
                    const projectMeta = mockProjectToProjectVersionMeta(mockProject, proj.componentIdOrNames);
                    results.projects.push(projectMeta);
                }
            });
            // Get dependencies
            if (!!recursive) {
                const deps = [...getDeps(results.projects)];
                results.dependencies.push(...deps);
            }
            return results;
        });
    }
    getCurrentUser() {
        return __awaiter(this, void 0, void 0, function* () {
            return true;
        });
    }
    projectComponents(projectId, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const { componentIdOrNames, version } = opts;
            if (PROJECTS.length <= 0) {
                throw new Error("Remember to call __addMockProject first!");
            }
            const maybeTokenPair = this.lastProjectIdsAndTokens.find((pair) => pair.projectId === projectId);
            const project = lang_utils_1.ensure(PROJECTS.find((p) => p.projectId === projectId));
            if (!((this.auth.user && this.auth.token) ||
                project.projectApiToken === (maybeTokenPair === null || maybeTokenPair === void 0 ? void 0 : maybeTokenPair.projectApiToken))) {
                throw new Error("No user+token and project API tokens don't match");
            }
            // Server also require tokens for the dependencies.
            const deps = [...getDeps([mockProjectToProjectVersionMeta(project)])];
            if (!deps.every((dep) => this.lastProjectIdsAndTokens.find((p) => p.projectId === dep.projectId))) {
                throw new Error("No user+token and project API tokens don't match on a dependency");
            }
            const mockComponents = getMockComponents(projectId, version, componentIdOrNames);
            if (mockComponents.length <= 0) {
                throw new Error(`Code gen failed: no components match the parameters ${JSON.stringify({ projectId, version, componentIdOrNames }, undefined, 2)}`);
            }
            const components = mockComponents.map((c) => genComponentBundle(c));
            const result = {
                components,
                codeComponentMetas: [],
                projectConfig: genProjectMetaBundle(projectId),
                globalVariants: [],
                usedTokens: genEmptyStyleTokensMap(),
                iconAssets: [],
                imageAssets: [],
                checksums: {
                    renderModuleChecksums: components.map((c) => [c.id, c.renderModule]),
                    cssRulesChecksums: components.map((c) => [c.id, c.cssRules]),
                    imageChecksums: [],
                    iconChecksums: [],
                    globalVariantChecksums: [],
                    projectCssChecksum: "",
                },
            };
            return result;
        });
    }
    uploadBundle(projectId, bundleName, bundleJs, css, metaJson) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("Unimplemented");
        });
    }
    projectStyleTokens(projectId) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("Unimplemented");
        });
    }
    projectIcons(projectId) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("Unimplemented");
        });
    }
    projectSyncMetadata(projectId, revision, rethrowAppError) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("Unimplemented");
        });
    }
    requiredPackages() {
        return __awaiter(this, void 0, void 0, function* () {
            return {
                "@plasmicapp/loader": "0.0.1",
                "@plasmicapp/cli": "0.0.1",
                "@plasmicapp/react-web": "0.0.1",
                "@plasmicapp/react-web-runtime": "0.0.1",
            };
        });
    }
    connectSocket() { }
    attachProjectIdsAndTokens(idsAndTokens) {
        this.lastProjectIdsAndTokens = idsAndTokens;
    }
}
api.PlasmicApi = PlasmicApi;
api.clear = clear;
api.getMockProject = getMockProject;
api.addMockProject = addMockProject;
api.stringToMockComponent = stringToMockComponent;
module.exports = api;
