"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const sync_1 = require("../actions/sync");
const fixtures_1 = require("../test-common/fixtures");
jest.mock("../api");
// Reset the test project directory
beforeEach(() => {
    fixtures_1.standardTestSetup(false);
});
afterEach(() => {
    fixtures_1.standardTestTeardown();
});
function removeAuth() {
    fixtures_1.opts.auth = undefined;
    // Don't need to remove this file, we just do for good measure.
    fixtures_1.tmpRepo.deletePlasmicAuth();
}
describe("Project API tokens", () => {
    test("is filled in by auth'd user so that a second run does not need auth", () => __awaiter(void 0, void 0, void 0, function* () {
        fixtures_1.opts.projects = ["projectId1"];
        yield expect(sync_1.sync(fixtures_1.opts)).resolves.toBeUndefined();
        fixtures_1.expectProject1Components();
        fixtures_1.expectProject1PlasmicJson();
        // Re-run, this time with no auth.
        removeAuth();
        yield expect(sync_1.sync(fixtures_1.opts)).resolves.toBeUndefined();
    }));
    test("can be passed in from command-line args", () => __awaiter(void 0, void 0, void 0, function* () {
        removeAuth();
        // Without specifying version.
        fixtures_1.opts.projects = ["projectId1:abc"];
        yield expect(sync_1.sync(fixtures_1.opts)).resolves.toBeUndefined();
        // Specifying version.
        fixtures_1.opts.projects = ["projectId1:abc@1.2.3"];
        yield expect(sync_1.sync(fixtures_1.opts)).resolves.toBeUndefined();
        // Wrong token (should fail).
        fixtures_1.opts.projects = ["projectId1:123"];
        yield expect(sync_1.sync(fixtures_1.opts)).rejects.toThrow("No user+token, and project API tokens don't match");
    }));
    test("is corrected by auth'd user if token was initially incorrect", () => __awaiter(void 0, void 0, void 0, function* () {
        fixtures_1.opts.projects = ["projectId1"];
        fixtures_1.tmpRepo.writePlasmicJson(Object.assign(Object.assign({}, fixtures_1.defaultPlasmicJson), { projects: [Object.assign(Object.assign({}, fixtures_1.project1Config), { projectApiToken: "blah" })] }));
        yield expect(sync_1.sync(fixtures_1.opts)).resolves.toBeUndefined();
        fixtures_1.expectProject1Components();
        fixtures_1.expectProject1PlasmicJson();
        // Re-run, this time with no auth.
        removeAuth();
        yield expect(sync_1.sync(fixtures_1.opts)).resolves.toBeUndefined();
    }));
    test("is filled in by auth'd user if project exists but token was initially missing", () => __awaiter(void 0, void 0, void 0, function* () {
        fixtures_1.opts.projects = ["projectId1"];
        fixtures_1.tmpRepo.writePlasmicJson(Object.assign(Object.assign({}, fixtures_1.defaultPlasmicJson), { projects: [fixtures_1.project1Config] }));
        yield expect(sync_1.sync(fixtures_1.opts)).resolves.toBeUndefined();
        fixtures_1.expectProject1Components();
        fixtures_1.expectProject1PlasmicJson();
        // Re-run, this time with no auth.
        removeAuth();
        yield expect(sync_1.sync(fixtures_1.opts)).resolves.toBeUndefined();
    }));
    test("when not available, should prompt for auth", () => __awaiter(void 0, void 0, void 0, function* () {
        fixtures_1.opts.projects = ["projectId1"];
        removeAuth();
        yield expect(sync_1.sync(fixtures_1.opts)).rejects.toThrow("Unable to authenticate");
    }));
    // TODO: Would be nice to eventually make this not fail outright but to prompt for auth.
    test("when incorrect, should fail", () => __awaiter(void 0, void 0, void 0, function* () {
        fixtures_1.opts.projects = ["projectId1"];
        removeAuth();
        fixtures_1.tmpRepo.writePlasmicJson(Object.assign(Object.assign({}, fixtures_1.defaultPlasmicJson), { projects: [Object.assign(Object.assign({}, fixtures_1.project1Config), { projectApiToken: "blah" })] }));
        yield expect(sync_1.sync(fixtures_1.opts)).rejects.toThrow("No user+token, and project API tokens don't match");
    }));
    test("works even if you have tokens for base but not deps", () => __awaiter(void 0, void 0, void 0, function* () {
        // Make project1 have a dependency.
        fixtures_1.standardTestSetup();
        fixtures_1.opts.projects = ["projectId1"];
        removeAuth();
        fixtures_1.tmpRepo.writePlasmicJson(Object.assign(Object.assign({}, fixtures_1.defaultPlasmicJson), { projects: [Object.assign(Object.assign({}, fixtures_1.project1Config), { projectApiToken: "abc" })] }));
        yield expect(sync_1.sync(fixtures_1.opts)).resolves.toBeUndefined();
        fixtures_1.expectProject1Components();
        fixtures_1.expectProjectAndDepPlasmicJson();
    }));
    test("works even if dependency was determined to not need an update", () => __awaiter(void 0, void 0, void 0, function* () {
        // Make project1 have a dependency.
        fixtures_1.standardTestSetup();
        fixtures_1.opts.projects = ["projectId1"];
        yield expect(sync_1.sync(fixtures_1.opts)).resolves.toBeUndefined();
        // We sync project1 which got updated, but the dependency is still same version.
        fixtures_1.opts.force = false;
        removeAuth();
        fixtures_1.mockApi.getMockProject("projectId1", "1.2.3").version = "1.2.4";
        yield expect(sync_1.sync(fixtures_1.opts)).resolves.toBeUndefined();
    }));
    test("should prompt for auth if you have only irrelevant tokens", () => __awaiter(void 0, void 0, void 0, function* () {
        fixtures_1.opts.projects = ["dependencyId1"];
        removeAuth();
        fixtures_1.tmpRepo.writePlasmicJson(Object.assign(Object.assign({}, fixtures_1.defaultPlasmicJson), { projects: [Object.assign(Object.assign({}, fixtures_1.project1Config), { projectApiToken: "abc" })] }));
        yield expect(sync_1.sync(fixtures_1.opts)).rejects.toThrow("Unable to authenticate");
    }));
    test("should use plasmic-loader.json for API tokens in loader mode", () => __awaiter(void 0, void 0, void 0, function* () {
        process.env.PLASMIC_LOADER = "1";
        fixtures_1.opts.projects = ["projectId1"];
        yield expect(sync_1.sync(fixtures_1.opts)).resolves.toBeUndefined();
        const loaderConfig = fixtures_1.tmpRepo.readPlasmicLoaderJson();
        expect(loaderConfig).toEqual({
            projects: [
                {
                    projectId: "projectId1",
                    projectApiToken: "abc",
                },
            ],
        });
        // Re-run, this time with no auth and no tokens in plasmic.json, only in plasmic-loader.json.
        removeAuth();
        fixtures_1.tmpRepo.writePlasmicJson(fixtures_1.defaultPlasmicJson);
        yield expect(sync_1.sync(fixtures_1.opts)).resolves.toBeUndefined();
        delete process.env["PLASMIC_LOADER"];
    }));
    test("works in PlasmicLoader mode even if root project was determined to not need an update", () => __awaiter(void 0, void 0, void 0, function* () {
        process.env.PLASMIC_LOADER = "1";
        // Make project1 have a dependency.
        fixtures_1.standardTestSetup();
        // Explicitly sync both - we had a bug writing back the plasmic-loader.json in this case.
        fixtures_1.opts.projects = ["projectId1", "dependencyId1"];
        yield expect(sync_1.sync(fixtures_1.opts)).resolves.toBeUndefined();
        // We sync project1 which got updated, but the dependency is still same version.
        fixtures_1.opts.force = false;
        removeAuth();
        fixtures_1.mockApi.getMockProject("projectId1", "1.2.3").version = "1.2.4";
        yield expect(sync_1.sync(fixtures_1.opts)).resolves.toBeUndefined();
    }));
    test("should fail in loader mode if not available", () => __awaiter(void 0, void 0, void 0, function* () {
        process.env.PLASMIC_LOADER = "1";
        fixtures_1.opts.projects = ["projectId1"];
        removeAuth();
        yield expect(sync_1.sync(fixtures_1.opts)).rejects.toThrow();
        delete process.env["PLASMIC_LOADER"];
    }));
});
