"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDependencies = exports.checkVersionResolution = void 0;
const lodash_1 = __importDefault(require("lodash"));
const deps_1 = require("../deps");
const config_utils_1 = require("./config-utils");
const error_1 = require("./error");
const lang_utils_1 = require("./lang-utils");
const semver = __importStar(require("./semver"));
const user_utils_1 = require("./user-utils");
/**
 * Starting at the root, do a BFS of the full dependency tree
 * Because ProjectVersionMeta only stores the (projectId, version),
 * we need to search for the full ProjectVersionMeta of dependencies from `available`
 * @param root
 * @param versionResolution
 */
function walkDependencyTree(root, available) {
    const queue = [root];
    const result = [];
    const getMeta = (projectId, version) => {
        const meta = available.find((m) => m.projectId === projectId && m.version === version);
        if (!meta) {
            throw new Error(`Cannot find projectId=${projectId}, version=${version} in the sync resolution results.`);
        }
        return meta;
    };
    while (queue.length > 0) {
        const curr = lang_utils_1.ensure(queue.shift());
        result.push(curr);
        queue.push(...lodash_1.default.toPairs(curr.dependencies).map(([projectId, version]) => getMeta(projectId, version)));
    }
    return result;
}
/**
 * For a given project, check if its compatible with plasmic.json, plasmic.lock, and user
 * @param meta
 * @param context
 */
function checkProjectMeta(meta, root, context, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const projectId = meta.projectId;
        const projectName = meta.projectName;
        const newVersion = meta.version;
        // Checks newVersion against plasmic.lock
        const checkVersionLock = () => __awaiter(this, void 0, void 0, function* () {
            const projectLock = context.lock.projects.find((p) => p.projectId === projectId);
            const versionOnDisk = projectLock === null || projectLock === void 0 ? void 0 : projectLock.version;
            if (semver.isLatest(newVersion)) {
                // Always sync when version set to "latest"
                return true;
            }
            if (!versionOnDisk) {
                // Always sync if we haven't seen sync'ed before
                return true;
            }
            if (semver.isLatest(versionOnDisk)) {
                // Explicitly allow downgrades from "latest" to published version
                return true;
            }
            // At this point, we can assume newVersion is always X.Y.Z (not latest)
            if (semver.eq(newVersion, versionOnDisk)) {
                if (opts.force) {
                    deps_1.logger.info(`Project '${projectName}'@${newVersion} is already up to date, but syncing anyway because --force is used`);
                    return true;
                }
                else {
                    deps_1.logger.info(`Project '${projectName}'@${newVersion} is already up to date; skipping. (To force an update, run again with "--force")`);
                    return false;
                }
            }
            if (semver.lt(newVersion, versionOnDisk)) {
                meta === root
                    ? deps_1.logger.warn(`The local version of '${projectName}' (${versionOnDisk}) is higher than requested version @${newVersion}. Plasmic does not support downgrading a project. You should consider updating the version range in ${config_utils_1.CONFIG_FILE_NAME}.`)
                    : deps_1.logger.warn(`'${root.projectName}' uses '${projectName}'@${newVersion}, but your code has '${projectName}'@${versionOnDisk}. You should consider upgrading this dependency in Plasmic Studio.`);
                return false;
            }
            if (semver.gt(newVersion, versionOnDisk)) {
                if (meta === root) {
                    return true;
                }
                else {
                    deps_1.logger.info(`'${root.projectName}' uses '${projectName}'@${newVersion}, but your code has version ${versionOnDisk}`);
                    return yield user_utils_1.confirmWithUser(`Do you want to upgrade '${projectName}' to ${newVersion}?`, opts.yes);
                }
            }
            throw new Error(`Error comparing version=${newVersion} with the version found in plasmic.lock (${versionOnDisk}) for '${projectName}'`);
        });
        // Checks newVersion against plasmic.json
        const checkVersionRange = () => __awaiter(this, void 0, void 0, function* () {
            const projectConfig = context.config.projects.find((p) => p.projectId === projectId);
            const versionRange = projectConfig === null || projectConfig === void 0 ? void 0 : projectConfig.version;
            // If haven't seen this before
            if (!versionRange) {
                // Always sync down dependencies if it's the first time to avoid compile/fix-imports error
                projectId !== root.projectId
                    ? deps_1.logger.info(`'${root.projectName}' uses '${projectName}', which has never been synced before. We will also sync '${projectName}'@${newVersion}.`)
                    : deps_1.logger.info(`'${projectName} has never been synced before. Syncing...'`);
                return true;
            }
            // If satisfies range in plasmic.json
            if (semver.satisfies(newVersion, versionRange)) {
                deps_1.logger.info(`Updating project '${projectName}' to ${newVersion}`);
                return true;
            }
            deps_1.logger.warn(`${projectName}@${newVersion} falls outside the range specified in ${config_utils_1.CONFIG_FILE_NAME} (${versionRange})\nTip: To avoid this warning in the future, update your ${config_utils_1.CONFIG_FILE_NAME}.`);
            return yield user_utils_1.confirmWithUser("Do you want to force it?", opts.force || opts.yes, "n");
        });
        const projectIds = opts.projects.length > 0
            ? opts.projects
            : context.config.projects.map((p) => p.projectId);
        if (projectIds.includes(projectId) && opts.force) {
            // if --force is used, and this is in the list of projects to sync, then
            // we should always sync it, even if nothing has changed
            return true;
        }
        return (yield checkVersionLock()) && (yield checkVersionRange());
    });
}
/**
 * Checks the versionResolution with plasmic.json, plasmic.lock, and user prompts
 * to compute which projects should be synced
 * @param versionResolution
 * @param context
 */
function checkVersionResolution(versionResolution, context, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        // Fail if there's nothing to sync
        if (versionResolution.projects.length <= 0) {
            throw new error_1.HandledError(`Found nothing to sync. Make sure the projectId and version values are valid in ${config_utils_1.CONFIG_FILE_NAME}.`);
        }
        const seen = [];
        const result = [];
        for (const root of versionResolution.projects) {
            const queue = opts.nonRecursive
                ? [root]
                : walkDependencyTree(root, versionResolution.dependencies).reverse();
            for (const m of queue) {
                // If we haven't seen this yet
                if (!seen.find((p) => p.projectId === m.projectId)) {
                    if (yield checkProjectMeta(m, root, context, opts)) {
                        result.push(m);
                    }
                    seen.push(m);
                }
            }
        }
        // Ignore repeats
        return result;
    });
}
exports.checkVersionResolution = checkVersionResolution;
function getDependencies(projectId, version, versionResolution) {
    var _a;
    const filterFn = (m) => m.projectId === projectId && m.version === version;
    const meta = (_a = versionResolution.projects.find(filterFn)) !== null && _a !== void 0 ? _a : versionResolution.dependencies.find(filterFn);
    return meta === null || meta === void 0 ? void 0 : meta.dependencies;
}
exports.getDependencies = getDependencies;
