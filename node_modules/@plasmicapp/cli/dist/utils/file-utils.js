"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.existsBuffered = exports.deleteFileBuffered = exports.renameFileBuffered = exports.readFileText = exports.writeFileText = exports.withBufferedFs = exports.assertAllPathsInRootDir = exports.fixAllFilePaths = exports.findFile = exports.findSrcDirPath = exports.buildBaseNameToFiles = exports.renameFile = exports.makeFilePath = exports.fileExists = exports.deleteFile = exports.readFileContent = exports.writeFileContent = exports.defaultPagePath = exports.defaultPublicResourcePath = exports.defaultResourcePath = exports.writeFileContentRaw = exports.stripExtension = void 0;
const fs_1 = __importDefault(require("fs"));
const glob_1 = __importDefault(require("glob"));
const lodash_1 = __importDefault(require("lodash"));
const upath_1 = __importDefault(require("upath"));
const deps_1 = require("../deps");
const error_1 = require("../utils/error");
const code_utils_1 = require("./code-utils");
const config_utils_1 = require("./config-utils");
const lang_utils_1 = require("./lang-utils");
const user_utils_1 = require("./user-utils");
function stripExtension(filename, removeComposedPath = false) {
    const ext = removeComposedPath
        ? filename.substring(filename.indexOf("."))
        : upath_1.default.extname(filename);
    if (!ext || filename === ext) {
        return filename;
    }
    return filename.substring(0, filename.lastIndexOf(ext));
}
exports.stripExtension = stripExtension;
function writeFileContentRaw(filePath, content, opts) {
    return __awaiter(this, void 0, void 0, function* () {
        opts = opts || {};
        if (existsBuffered(filePath) && !opts.force) {
            const overwrite = yield user_utils_1.confirmWithUser(`File ${filePath} already exists. Do you want to overwrite?`, opts.yes);
            if (!overwrite) {
                throw new error_1.HandledError(`Cannot write to ${filePath}; file already exists.`);
            }
        }
        fs_1.default.mkdirSync(upath_1.default.dirname(filePath), { recursive: true });
        writeFileText(filePath, content);
    });
}
exports.writeFileContentRaw = writeFileContentRaw;
function defaultResourcePath(context, project, ...subpaths) {
    const projectName = lodash_1.default.isString(project) ? project : project.projectName;
    return upath_1.default.join(context.config.defaultPlasmicDir, lodash_1.default.snakeCase(projectName), ...subpaths);
}
exports.defaultResourcePath = defaultResourcePath;
function defaultPublicResourcePath(context, project, ...subpaths) {
    return upath_1.default.join(context.config.images.publicDir, "plasmic", lodash_1.default.snakeCase(project.projectName), ...subpaths);
}
exports.defaultPublicResourcePath = defaultPublicResourcePath;
function defaultPagePath(context, fileName) {
    var _a, _b;
    if (context.config.platform === "nextjs") {
        return upath_1.default.join(((_a = context.config.nextjsConfig) === null || _a === void 0 ? void 0 : _a.pagesDir) || "", fileName);
    }
    if (context.config.platform === "gatsby") {
        return upath_1.default.join(((_b = context.config.gatsbyConfig) === null || _b === void 0 ? void 0 : _b.pagesDir) || "", fileName);
    }
    return fileName;
}
exports.defaultPagePath = defaultPagePath;
function writeFileContent(context, srcDirFilePath, content, opts = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const path = makeFilePath(context, srcDirFilePath);
        yield writeFileContentRaw(path, content, Object.assign({ yes: context.cliArgs.yes }, opts));
    });
}
exports.writeFileContent = writeFileContent;
function readFileContent(context, srcDirFilePath) {
    const path = makeFilePath(context, srcDirFilePath);
    return readFileText(path);
}
exports.readFileContent = readFileContent;
function deleteFile(context, srcDirFilePath) {
    const path = makeFilePath(context, srcDirFilePath);
    deleteFileBuffered(path);
}
exports.deleteFile = deleteFile;
function fileExists(context, srcDirFilePath) {
    return existsBuffered(makeFilePath(context, srcDirFilePath));
}
exports.fileExists = fileExists;
function makeFilePath(context, filePath) {
    return upath_1.default.isAbsolute(filePath)
        ? filePath
        : upath_1.default.join(context.absoluteSrcDir, filePath);
}
exports.makeFilePath = makeFilePath;
function renameFile(context, oldPath, newPath) {
    renameFileBuffered(makeFilePath(context, oldPath), makeFilePath(context, newPath));
}
exports.renameFile = renameFile;
/**
 * Returns absolute paths of all Plasmic managed files found, grouped by each basename
 * for example:
 * {
 * "file.txt": [ "/path1/file.txt", "/path2.txt" ]
 * ...
 * }
 * @param {PlasmicContext} context
 * @returns {Record<string, string[]>}
 **/
function buildBaseNameToFiles(context) {
    const srcDir = context.absoluteSrcDir;
    const scriptFileExt = context.config.code.lang === "ts" ? "tsx" : "jsx";
    const allFiles = glob_1.default.sync(`${srcDir}/**/*.+(ts|css|${scriptFileExt}|json)`, {
        ignore: [`${srcDir}/**/node_modules/**/*`],
    });
    return lodash_1.default.groupBy(allFiles, (f) => upath_1.default.basename(f));
}
exports.buildBaseNameToFiles = buildBaseNameToFiles;
/**
 * Tries to find the file at `srcDir/expectedPath`.  If it's not there, tries to detect if it has
 * been moved to a different location.  Returns the found location relative to the `srcDir`.
 *
 * If `expectedPath` doesn't exist, but there's more than one file of that name in `baseNameToFiles`, then
 * error and quit.  If no file of that name can be found, `expectedPath` is returned.
 */
function findSrcDirPath(absoluteSrcDir, expectedPath, baseNameToFiles) {
    if (!upath_1.default.isAbsolute(absoluteSrcDir)) {
        throw new error_1.HandledError("Cannot find srcDir. Please check plasmic.json.");
    }
    const fileName = upath_1.default.basename(expectedPath);
    if (existsBuffered(upath_1.default.join(absoluteSrcDir, expectedPath))) {
        return expectedPath;
    }
    else if (!(fileName in baseNameToFiles)) {
        return expectedPath;
    }
    else if (baseNameToFiles[fileName].length === 1) {
        // There's only one file of the same name, so maybe we've been moved there?
        const newPath = upath_1.default.relative(absoluteSrcDir, baseNameToFiles[fileName][0]);
        deps_1.logger.info(`\tDetected file moved from ${expectedPath} to ${newPath}`);
        return newPath;
    }
    else {
        throw new error_1.HandledError(`Cannot find expected file at ${expectedPath}, and found multiple possible matching files ${baseNameToFiles[fileName]}.  Please update plasmic.config with the real location for ${fileName}.`);
    }
}
exports.findSrcDirPath = findSrcDirPath;
/**
 * Finds the full path to the first file satisfying `pred` in `dir`.  If
 * `opts.traverseParents` is set to true, then will also look in ancestor
 * directories until the plasmic.json file is found.  If none is found,
 * returns undefined.
 */
function findFile(dir, pred, opts) {
    const files = fs_1.default.readdirSync(dir);
    const found = files.find((f) => pred(f));
    if (found) {
        return upath_1.default.join(dir, found);
    }
    if (!opts.traverseParents) {
        return undefined;
    }
    const parent = upath_1.default.dirname(dir);
    if (parent === dir) {
        // We've hit the root dir already
        return undefined;
    }
    return findFile(upath_1.default.dirname(dir), pred, opts);
}
exports.findFile = findFile;
/**
 * Parses a configuration and returns file/dir paths in it (in the format
 * BundleKeyPair to allow the caller to change these paths).
 */
function getAllPaths(context) {
    const config = context.config;
    const pairs = [];
    const pushPath = (bundle, key) => {
        pairs.push({ bundle, key });
    };
    const pushComponent = (comp) => {
        pushPath(comp, "renderModuleFilePath");
        pushPath(comp, "cssFilePath");
        if (code_utils_1.isLocalModulePath(comp.importSpec.modulePath)) {
            pushPath(comp.importSpec, "modulePath");
        }
    };
    const pushProject = (proj) => {
        pushPath(proj, "cssFilePath");
        for (const component of proj.components) {
            pushComponent(component);
        }
        for (const icon of proj.icons) {
            pushPath(icon, "moduleFilePath");
        }
        for (const image of proj.images) {
            pushPath(image, "filePath");
        }
    };
    for (const project of config.projects) {
        pushProject(project);
    }
    for (const bundle of config.globalVariants.variantGroups) {
        pushPath(bundle, "contextFilePath");
    }
    pushPath(config.tokens, "tokensFilePath");
    pushPath(config.style, "defaultStyleCssFilePath");
    pushPath(config, "defaultPlasmicDir");
    if (config.images.publicDir) {
        pushPath(config.images, "publicDir");
    }
    if (config.gatsbyConfig) {
        pushPath(config.gatsbyConfig, "pagesDir");
    }
    if (config.nextjsConfig) {
        pushPath(config.nextjsConfig, "pagesDir");
    }
    return pairs;
}
/**
 * Fixes all src-relative file paths in PlasmicConfig by detecting file
 * movement on disk.
 */
function fixAllFilePaths(context) {
    return __awaiter(this, void 0, void 0, function* () {
        const baseNameToFiles = buildBaseNameToFiles(context);
        let changed = false;
        const paths = getAllPaths(context);
        for (const { bundle, key } of paths) {
            const known = bundle[key];
            // Check null and undefined
            if (known == null) {
                throw new error_1.HandledError(`"${key} is required, but missing in ${config_utils_1.CONFIG_FILE_NAME}. Please restore the file or delete from ${config_utils_1.CONFIG_FILE_NAME} and run plasmic sync: ${bundle}"`);
            }
            // Check falsey values (e.g. "")
            if (!known) {
                continue;
            }
            const found = findSrcDirPath(context.absoluteSrcDir, known, baseNameToFiles);
            if (known !== found) {
                bundle[key] = found;
                changed = true;
            }
        }
        if (changed) {
            yield config_utils_1.updateConfig(context, context.config);
        }
    });
}
exports.fixAllFilePaths = fixAllFilePaths;
/**
 * Throws an error if some file in PlasmicConfig is not inside the root
 * directory (i.e., the directory containing plasmic.json).
 */
function assertAllPathsInRootDir(context) {
    // Do not run this check when running in PlasmicLoader environment
    if (process.env.PLASMIC_LOADER) {
        return;
    }
    if (!context.absoluteSrcDir.startsWith(context.rootDir)) {
        throw new error_1.HandledError(`"srcDir" in ${config_utils_1.CONFIG_FILE_NAME} is outside of ${context.rootDir}`);
    }
    const paths = getAllPaths(context);
    for (const { bundle, key } of paths) {
        const relPath = bundle[key];
        if (!relPath) {
            continue;
        }
        const absPath = upath_1.default.resolve(context.absoluteSrcDir, relPath);
        if (!absPath.startsWith(context.rootDir)) {
            throw new error_1.HandledError(`The path "${relPath}" in ${config_utils_1.CONFIG_FILE_NAME} is outside of ${context.rootDir}`);
        }
    }
}
exports.assertAllPathsInRootDir = assertAllPathsInRootDir;
/** Whether we're currently recording to the buffer. */
let buffering = false;
/** List of buffer actions. */
const buffer = new Map();
const renamedFiles = new Map();
/**
 * This turns on buffering of file writes/reads.
 *
 * This is useful for reducing the extent to which our file updates are scattered over time, which can cause webpack
 * dev server to trip up.
 *
 * This also has the side benefit of making our CLI commands more atomic, in case of failure partway through a sync.
 */
function withBufferedFs(f) {
    return __awaiter(this, void 0, void 0, function* () {
        buffering = true;
        buffer.clear();
        renamedFiles.clear();
        try {
            yield f();
            for (const [filePath, action] of buffer.entries()) {
                switch (action.type) {
                    case "create":
                        fs_1.default.mkdirSync(upath_1.default.dirname(filePath), { recursive: true });
                        // eslint-disable-next-line no-restricted-properties
                        fs_1.default.writeFileSync(filePath, action.content);
                        break;
                    case "rename":
                        fs_1.default.mkdirSync(upath_1.default.dirname(action.newPath), { recursive: true });
                        // eslint-disable-next-line no-restricted-properties
                        fs_1.default.renameSync(filePath, action.newPath);
                        break;
                    case "delete":
                        // eslint-disable-next-line no-restricted-properties
                        fs_1.default.unlinkSync(filePath);
                        break;
                }
            }
        }
        finally {
            buffering = false;
        }
    });
}
exports.withBufferedFs = withBufferedFs;
function writeFileText(path, content) {
    if (buffering) {
        buffer.set(path, { type: "create", content });
    }
    else {
        // eslint-disable-next-line no-restricted-properties
        fs_1.default.writeFileSync(path, content, "utf8");
    }
}
exports.writeFileText = writeFileText;
function readFileText(path) {
    if (buffering) {
        const action = buffer.get(path);
        if (action) {
            switch (action.type) {
                case "create":
                    return lang_utils_1.ensureString(action.content);
                case "rename":
                    return readFileText(action.newPath);
                case "delete":
                    throw new error_1.HandledError("File does not exists");
            }
        }
    }
    // eslint-disable-next-line no-restricted-properties
    return fs_1.default.readFileSync(path, "utf8");
}
exports.readFileText = readFileText;
function renameFileBuffered(oldPath, newPath) {
    if (oldPath === newPath) {
        return;
    }
    if (buffering) {
        if (!existsBuffered(oldPath)) {
            throw new error_1.HandledError("File does not exists");
        }
        const action = buffer.get(oldPath);
        if (action) {
            switch (action.type) {
                case "create":
                    buffer.set(newPath, action);
                    buffer.delete(oldPath);
                    break;
                case "rename":
                    throw new error_1.HandledError("File does not exists");
                case "delete":
                    throw new error_1.HandledError("File does not exists");
            }
        }
        const renamedFile = renamedFiles.get(oldPath);
        if (renamedFile !== undefined) {
            oldPath = renamedFile;
        }
        buffer.set(oldPath, { type: "rename", newPath });
        renamedFiles.set(newPath, oldPath);
    }
    else {
        fs_1.default.mkdirSync(upath_1.default.dirname(newPath), { recursive: true });
        // eslint-disable-next-line no-restricted-properties
        fs_1.default.renameSync(oldPath, newPath);
    }
}
exports.renameFileBuffered = renameFileBuffered;
function deleteFileBuffered(path) {
    if (buffering) {
        if (!existsBuffered(path)) {
            throw new error_1.HandledError("File does not exists");
        }
        const action = buffer.get(path);
        if (action) {
            switch (action.type) {
                case "create":
                    buffer.delete(path);
                    break;
                case "rename":
                    throw new error_1.HandledError("File does not exists");
                case "delete":
                    throw new error_1.HandledError("File does not exists");
            }
        }
        else {
            buffer.set(path, { type: "delete" });
        }
        renamedFiles.delete(path);
    }
    else {
        // eslint-disable-next-line no-restricted-properties
        fs_1.default.unlinkSync(path);
    }
}
exports.deleteFileBuffered = deleteFileBuffered;
function existsBuffered(path) {
    if (buffering) {
        if (renamedFiles.has(path)) {
            return true;
        }
        const action = buffer.get(path);
        if (action) {
            switch (action.type) {
                case "create":
                    return true;
                case "rename":
                    return false;
                case "delete":
                    return false;
            }
        }
    }
    // eslint-disable-next-line no-restricted-properties
    return fs_1.default.existsSync(path);
}
exports.existsBuffered = existsBuffered;
