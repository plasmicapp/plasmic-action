/// <reference types="node" />
import { ProjectMetaBundle } from "../api";
import { PlasmicContext, ProjectConfig } from "./config-utils";
export declare function stripExtension(filename: string, removeComposedPath?: boolean): string;
export declare function writeFileContentRaw(filePath: string, content: string | Buffer, opts?: {
    force?: boolean;
    yes?: boolean;
}): Promise<void>;
export declare function defaultResourcePath(context: PlasmicContext, project: ProjectConfig | ProjectMetaBundle | string, ...subpaths: string[]): string;
export declare function defaultPublicResourcePath(context: PlasmicContext, project: ProjectConfig, ...subpaths: string[]): string;
export declare function defaultPagePath(context: PlasmicContext, fileName: string): string;
export declare function writeFileContent(context: PlasmicContext, srcDirFilePath: string, content: string | Buffer, opts?: {
    force?: boolean;
}): Promise<void>;
export declare function readFileContent(context: PlasmicContext, srcDirFilePath: string): string;
export declare function deleteFile(context: PlasmicContext, srcDirFilePath: string): void;
export declare function fileExists(context: PlasmicContext, srcDirFilePath: string): boolean;
export declare function makeFilePath(context: PlasmicContext, filePath: string): string;
export declare function renameFile(context: PlasmicContext, oldPath: string, newPath: string): void;
/**
 * Returns absolute paths of all Plasmic managed files found, grouped by each basename
 * for example:
 * {
 * "file.txt": [ "/path1/file.txt", "/path2.txt" ]
 * ...
 * }
 * @param {PlasmicContext} context
 * @returns {Record<string, string[]>}
 **/
export declare function buildBaseNameToFiles(context: PlasmicContext): Record<string, string[]>;
/**
 * Tries to find the file at `srcDir/expectedPath`.  If it's not there, tries to detect if it has
 * been moved to a different location.  Returns the found location relative to the `srcDir`.
 *
 * If `expectedPath` doesn't exist, but there's more than one file of that name in `baseNameToFiles`, then
 * error and quit.  If no file of that name can be found, `expectedPath` is returned.
 */
export declare function findSrcDirPath(absoluteSrcDir: string, expectedPath: string, baseNameToFiles: Record<string, string[]>): string;
/**
 * Finds the full path to the first file satisfying `pred` in `dir`.  If
 * `opts.traverseParents` is set to true, then will also look in ancestor
 * directories until the plasmic.json file is found.  If none is found,
 * returns undefined.
 */
export declare function findFile(dir: string, pred: (name: string) => boolean, opts: {
    traverseParents?: boolean;
}): string | undefined;
/**
 * Fixes all src-relative file paths in PlasmicConfig by detecting file
 * movement on disk.
 */
export declare function fixAllFilePaths(context: PlasmicContext): Promise<void>;
/**
 * Throws an error if some file in PlasmicConfig is not inside the root
 * directory (i.e., the directory containing plasmic.json).
 */
export declare function assertAllPathsInRootDir(context: PlasmicContext): void;
/**
 * This turns on buffering of file writes/reads.
 *
 * This is useful for reducing the extent to which our file updates are scattered over time, which can cause webpack
 * dev server to trip up.
 *
 * This also has the side benefit of making our CLI commands more atomic, in case of failure partway through a sync.
 */
export declare function withBufferedFs(f: () => Promise<void>): Promise<void>;
export declare function writeFileText(path: string, content: string | Buffer): void;
export declare function readFileText(path: string): string;
export declare function renameFileBuffered(oldPath: string, newPath: string): void;
export declare function deleteFileBuffered(path: string): void;
export declare function existsBuffered(path: string): boolean;
