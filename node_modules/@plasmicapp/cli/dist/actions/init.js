"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getYargsOption = exports.getInitArgsChoices = exports.getInitArgsQuestion = exports.getInitArgsLongDescription = exports.getInitArgsShortDescription = exports.initPlasmic = void 0;
const chalk_1 = __importDefault(require("chalk"));
const inquirer_1 = __importDefault(require("inquirer"));
const lodash_1 = __importDefault(require("lodash"));
const upath_1 = __importDefault(require("upath"));
const deps_1 = require("../deps");
const auth_utils_1 = require("../utils/auth-utils");
const config_utils_1 = require("../utils/config-utils");
const envdetect_1 = require("../utils/envdetect");
const file_utils_1 = require("../utils/file-utils");
const lang_utils_1 = require("../utils/lang-utils");
const npm_utils_1 = require("../utils/npm-utils");
const user_utils_1 = require("../utils/user-utils");
function initPlasmic(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!opts.baseDir)
            opts.baseDir = process.cwd();
        yield auth_utils_1.getOrStartAuth(opts);
        const configFile = opts.config || config_utils_1.findConfigFile(opts.baseDir, { traverseParents: false });
        if (configFile && file_utils_1.existsBuffered(configFile)) {
            deps_1.logger.error("You already have a plasmic.json file! Please either delete or edit it directly.");
            return;
        }
        // path to plasmic.json
        const newConfigFile = opts.config || upath_1.default.join(opts.baseDir, config_utils_1.CONFIG_FILE_NAME);
        const answers = yield deriveInitAnswers(opts);
        yield config_utils_1.writeConfig(newConfigFile, createInitConfig(answers), opts.baseDir);
        if (!process.env.QUIET) {
            deps_1.logger.info("Successfully created plasmic.json.\n");
        }
        const answer = yield user_utils_1.confirmWithUser("@plasmicapp/react-web is a small runtime required by Plasmic-generated code.\n  Do you want to add it now?", opts.yes);
        if (answer) {
            npm_utils_1.installUpgrade("@plasmicapp/react-web", opts.baseDir);
        }
    });
}
exports.initPlasmic = initPlasmic;
function createInitConfig(opts) {
    return config_utils_1.fillDefaults(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ srcDir: opts.srcDir, defaultPlasmicDir: opts.plasmicDir }, (opts.platform === "nextjs" && {
        nextjsConfig: {
            pagesDir: opts.pagesDir,
        },
    })), (opts.platform === "gatsby" && {
        gatsbyConfig: {
            pagesDir: opts.pagesDir,
        },
    })), { code: Object.assign(Object.assign(Object.assign({}, (opts.codeLang && { lang: opts.codeLang })), (opts.codeScheme && { scheme: opts.codeScheme })), (opts.reactRuntime && { reactRuntime: opts.reactRuntime })), style: Object.assign({}, (opts.styleScheme && { scheme: opts.styleScheme })), images: Object.assign(Object.assign(Object.assign({}, (opts.imagesScheme && { scheme: opts.imagesScheme })), (opts.imagesScheme && { publicDir: opts.imagesPublicDir })), (opts.imagesScheme && { publicUrlPrefix: opts.imagesPublicUrlPrefix })) }), (opts.platform && { platform: opts.platform })), { cliVersion: npm_utils_1.getCliVersion() }));
}
/**
 * Pretty-print the question along with the default answer, as if that was the choice
 * being made. Don't actually interactively prompt for a response.
 */
function simulatePrompt(question, defaultAnswer, bold = false) {
    var _a, _b, _c;
    const message = question.message.endsWith(">")
        ? question.message
        : question.message + ">";
    process.stdout.write((bold ? chalk_1.default.bold(message) : message) + " ");
    deps_1.logger.info(chalk_1.default.cyan((_c = (_b = (_a = question.choices) === null || _a === void 0 ? void 0 : _a.call(question).find((choice) => choice.value === defaultAnswer)) === null || _b === void 0 ? void 0 : _b.name) !== null && _c !== void 0 ? _c : defaultAnswer));
}
function deriveInitAnswers(opts) {
    return __awaiter(this, void 0, void 0, function* () {
        const plasmicRootDir = opts.config ? upath_1.default.dirname(opts.config) : opts.baseDir;
        const platform = !!opts.platform
            ? opts.platform
            : envdetect_1.detectNextJs()
                ? "nextjs"
                : envdetect_1.detectGatsby()
                    ? "gatsby"
                    : "react";
        const isCra = envdetect_1.detectCreateReactApp();
        const isNext = platform === "nextjs";
        const isGatsby = platform === "gatsby";
        const isGeneric = !isCra && !isNext && !isGatsby;
        const isTypescript = envdetect_1.detectTypescript();
        if (isNext) {
            deps_1.logger.info("Detected Next.js...");
        }
        else if (isGatsby) {
            deps_1.logger.info("Detected Gatsby...");
        }
        else if (isCra) {
            deps_1.logger.info("Detected create-react-app...");
        }
        // Platform-specific defaults that take precedent
        const deriver = isNext
            ? getNextDefaults(plasmicRootDir)
            : isGatsby
                ? getGatsbyDefaults(plasmicRootDir)
                : isCra
                    ? getCraDefaults(plasmicRootDir)
                    : getGenericDefaults(plasmicRootDir);
        const srcDir = lang_utils_1.ensureString(deriver.srcDir);
        const getDefaultAnswer = (name, defaultAnswer) => {
            // Try to get the user CLI arg override first
            if (opts[name]) {
                return opts[name];
            }
            else if (deriver[name]) {
                // Then get the platform-specific default
                if (lodash_1.default.isFunction(deriver[name])) {
                    const fn = deriver[name];
                    return fn(srcDir);
                }
                return deriver[name];
            }
            else {
                // Other specified default
                return defaultAnswer;
            }
        };
        // Start with a complete set of defaults. Some of these are not worth displaying.
        const answers = {
            host: getDefaultAnswer("host", ""),
            platform,
            codeLang: getDefaultAnswer("codeLang", isTypescript ? "ts" : "js"),
            codeScheme: getDefaultAnswer("codeScheme", config_utils_1.DEFAULT_CONFIG.code.scheme),
            styleScheme: getDefaultAnswer("styleScheme", config_utils_1.DEFAULT_CONFIG.style.scheme),
            imagesScheme: getDefaultAnswer("imagesScheme", config_utils_1.DEFAULT_CONFIG.images.scheme),
            imagesPublicDir: getDefaultAnswer("imagesPublicDir", lang_utils_1.ensure(config_utils_1.DEFAULT_PUBLIC_FILES_CONFIG.publicDir)),
            imagesPublicUrlPrefix: getDefaultAnswer("imagesPublicUrlPrefix", lang_utils_1.ensure(config_utils_1.DEFAULT_PUBLIC_FILES_CONFIG.publicUrlPrefix)),
            srcDir: getDefaultAnswer("srcDir", config_utils_1.DEFAULT_CONFIG.srcDir),
            plasmicDir: getDefaultAnswer("plasmicDir", config_utils_1.DEFAULT_CONFIG.defaultPlasmicDir),
            pagesDir: getDefaultAnswer("pagesDir", undefined),
            reactRuntime: getDefaultAnswer("reactRuntime", "classic"),
        };
        const prominentAnswers = lodash_1.default.omit(answers, "codeScheme");
        if (process.env.QUIET) {
            return answers;
        }
        deps_1.logger.info(chalk_1.default.bold("Plasmic Express Setup -- Here are the default settings we recommend:\n"));
        yield performAsks(true);
        // Allow a user to short-circuit
        const useExpressQuestion = {
            name: "continue",
            message: `Would you like to accept these defaults?`,
            type: "list",
            choices: () => [
                {
                    value: "yes",
                    name: "Accept these defaults",
                },
                {
                    value: "no",
                    name: "Customize the choices",
                },
            ],
        };
        deps_1.logger.info("");
        if (opts.yes) {
            simulatePrompt(useExpressQuestion, "yes", true);
            return answers;
        }
        else {
            const useExpress = yield inquirer_1.default.prompt([useExpressQuestion]);
            if (useExpress.continue === "yes") {
                return answers;
            }
        }
        /**
         * @param express When true, we pretty-print the question along with the default answer, as if that was the choice
         * being made. This is for displaying the default choices in the express setup.
         */
        function performAsks(express) {
            return __awaiter(this, void 0, void 0, function* () {
                // Proceed with platform-specific prompts
                function maybePrompt(question) {
                    return __awaiter(this, void 0, void 0, function* () {
                        const name = lang_utils_1.ensure(question.name);
                        const message = lang_utils_1.ensure(question.message);
                        if (opts[name]) {
                            deps_1.logger.info(message + answers[name] + "(specified in CLI arg)");
                        }
                        else if (express) {
                            const defaultAnswer = answers[name];
                            simulatePrompt(question, defaultAnswer);
                        }
                        else if (!opts.yes && !deriver.alwaysDerived.includes(name)) {
                            const ans = yield inquirer_1.default.prompt(Object.assign(Object.assign({}, question), { default: answers[name] }));
                            // Not sure why TS complains here without this cast.
                            answers[name] = ans[name];
                        }
                        // Other questions are silently skipped
                    });
                }
                yield maybePrompt({
                    name: "srcDir",
                    message: `${getInitArgsQuestion("srcDir")}\n>`,
                });
                yield maybePrompt({
                    name: "plasmicDir",
                    message: `${getInitArgsQuestion("plasmicDir")} (This is relative to "${answers.srcDir}")\n>`,
                });
                if (config_utils_1.isPageAwarePlatform(platform)) {
                    yield maybePrompt({
                        name: "pagesDir",
                        message: `${getInitArgsQuestion("pagesDir")} (This is relative to "${answers.srcDir}")\n>`,
                    });
                }
                yield maybePrompt({
                    name: "codeLang",
                    message: `${getInitArgsQuestion("codeLang")}\n`,
                    type: "list",
                    choices: () => [
                        {
                            name: `Typescript${isTypescript ? " (tsconfig.json detected)" : ""}`,
                            value: "ts",
                        },
                        {
                            name: `Javascript${!isTypescript ? " (no tsconfig.json detected)" : ""}`,
                            value: "js",
                        },
                    ],
                });
                yield maybePrompt({
                    name: "styleScheme",
                    message: `${getInitArgsQuestion("styleScheme")}\n`,
                    type: "list",
                    choices: () => [
                        {
                            name: `CSS modules, imported as "import sty from './plasmic.module.css'"`,
                            value: "css-modules",
                        },
                        {
                            name: `Plain CSS stylesheets, imported as "import './plasmic.css'"`,
                            value: "css",
                        },
                    ],
                });
                yield maybePrompt({
                    name: "imagesScheme",
                    message: `${getInitArgsQuestion("imagesScheme")}\n`,
                    type: "list",
                    choices: () => [
                        {
                            name: `Imported as files, like "import img from './image.png'". ${isGeneric ? "Not all bundlers support this." : ""}`,
                            value: "files",
                        },
                        {
                            name: `Images stored in a public folder, referenced like <img src="/static/image.png"/>`,
                            value: "public-files",
                        },
                        {
                            name: `Inlined as base64-encoded data URIs`,
                            value: "inlined",
                        },
                    ],
                });
                if (answers.imagesScheme === "public-files") {
                    yield maybePrompt({
                        name: "imagesPublicDir",
                        message: `${getInitArgsQuestion("imagesPublicDir")} (This is relative to "${answers.srcDir}")\n>`,
                    });
                    yield maybePrompt({
                        name: "imagesPublicUrlPrefix",
                        message: `${getInitArgsQuestion("imagesPublicUrlPrefix")} ${isNext ? `(for Next.js, this is usually "/")` : ""}\n>`,
                    });
                }
            });
        }
        yield performAsks(false);
        return answers;
    });
}
function getNextDefaults(plasmicRootDir) {
    var _a;
    const projectRootDir = (_a = npm_utils_1.findPackageJsonDir(plasmicRootDir)) !== null && _a !== void 0 ? _a : plasmicRootDir;
    return {
        srcDir: upath_1.default.relative(plasmicRootDir, upath_1.default.join(projectRootDir, "components")),
        pagesDir: (srcDir) => upath_1.default.relative(upath_1.default.join(plasmicRootDir, srcDir), upath_1.default.join(projectRootDir, "pages")),
        styleScheme: "css-modules",
        imagesScheme: "public-files",
        imagesPublicDir: (srcDir) => upath_1.default.relative(upath_1.default.join(plasmicRootDir, srcDir), upath_1.default.join(projectRootDir, "public")),
        imagesPublicUrlPrefix: "/",
        alwaysDerived: [
            "styleScheme",
            "imagesScheme",
            "imagesPublicDir",
            "pagesDir",
        ],
    };
}
function getGatsbyDefaults(plasmicRootDir) {
    var _a;
    const projectRootDir = (_a = npm_utils_1.findPackageJsonDir(plasmicRootDir)) !== null && _a !== void 0 ? _a : plasmicRootDir;
    return {
        srcDir: upath_1.default.relative(plasmicRootDir, upath_1.default.join(projectRootDir, "src", "components")),
        pagesDir: (srcDir) => {
            const absSrcDir = upath_1.default.join(plasmicRootDir, srcDir);
            const absPagesDir = upath_1.default.join(projectRootDir, "src", "pages");
            const relDir = upath_1.default.relative(absSrcDir, absPagesDir);
            return relDir;
        },
        styleScheme: "css-modules",
        imagesScheme: "files",
        imagesPublicDir: (srcDir) => upath_1.default.relative(upath_1.default.join(plasmicRootDir, srcDir), upath_1.default.join(projectRootDir, "static")),
        imagesPublicUrlPrefix: "/",
        alwaysDerived: ["imagesScheme", "pagesDir"],
    };
}
function getCraDefaults(plasmicRootDir) {
    var _a;
    const projectRootDir = (_a = npm_utils_1.findPackageJsonDir(plasmicRootDir)) !== null && _a !== void 0 ? _a : plasmicRootDir;
    return {
        srcDir: upath_1.default.relative(plasmicRootDir, upath_1.default.join(projectRootDir, "src", "components")),
        styleScheme: "css-modules",
        imagesScheme: "files",
        imagesPublicDir: (srcDir) => upath_1.default.relative(upath_1.default.join(plasmicRootDir, srcDir), upath_1.default.join(projectRootDir, "public")),
        alwaysDerived: [],
    };
}
function getGenericDefaults(plasmicRootDir) {
    var _a;
    const projectRootDir = (_a = npm_utils_1.findPackageJsonDir(plasmicRootDir)) !== null && _a !== void 0 ? _a : plasmicRootDir;
    const srcDir = file_utils_1.existsBuffered(upath_1.default.join(projectRootDir, "src"))
        ? upath_1.default.join(projectRootDir, "src", "components")
        : upath_1.default.join(projectRootDir, "components");
    return {
        srcDir: upath_1.default.relative(plasmicRootDir, srcDir),
        alwaysDerived: [],
    };
}
/**
 * Consolidating where we are specifying the descriptions of InitArgs
 */
const INIT_ARGS_DESCRIPTION = {
    host: {
        shortDescription: "Plasmic host to use",
    },
    platform: {
        shortDescription: "Target platform",
        longDescription: "Target platform to generate code for",
        choices: ["react", "nextjs", "gatsby"],
    },
    codeLang: {
        shortDescription: "Target language",
        longDescription: "Target language to generate code for",
        question: `What target language should Plasmic generate code in?`,
        choices: ["js", "ts"],
    },
    codeScheme: {
        shortDescription: "Code generation scheme",
        longDescription: "Code generation scheme to use",
        choices: ["blackbox", "direct"],
    },
    styleScheme: {
        shortDescription: "Styling framework",
        longDescription: "Styling framework to use",
        question: "How should we generate css for Plasmic components?",
        choices: ["css", "css-modules"],
    },
    imagesScheme: {
        shortDescription: "Image scheme",
        longDescription: "How to reference used image files",
        question: "How should we reference image files used in Plasmic components?",
        choices: ["inlined", "files", "public-files"],
    },
    imagesPublicDir: {
        shortDescription: "Directory of public static files",
        longDescription: "Default directory to put public static files",
        question: "What directory should static image files be put into?",
    },
    imagesPublicUrlPrefix: {
        shortDescription: "URL prefix for static files",
        longDescription: "URL prefix from which the app will serve static files",
        question: "What's the URL prefix from which the app will serve static files?",
    },
    srcDir: {
        shortDescription: "Source directory",
        longDescription: "Default directory to put React component files (that you edit) into",
        question: "What directory should React component files (that you edit) be put into?",
    },
    plasmicDir: {
        shortDescription: "Plasmic-managed directory",
        longDescription: "Default directory to put Plasmic-managed files into; relative to src-dir",
        question: "What directory should Plasmic-managed files (that you should not edit) be put into?",
    },
    pagesDir: {
        shortDescription: "Pages directory",
        longDescription: "Default directory to put page files (that you edit) into",
        question: "What directory should pages be put into?",
    },
};
/**
 * Get the short description, which exists for all args
 * @param key
 * @returns
 */
function getInitArgsShortDescription(key) {
    var _a;
    return (_a = INIT_ARGS_DESCRIPTION[key]) === null || _a === void 0 ? void 0 : _a.shortDescription;
}
exports.getInitArgsShortDescription = getInitArgsShortDescription;
/**
 * Try to get a long description, falling back to the short description
 * @param key
 * @returns
 */
function getInitArgsLongDescription(key) {
    var _a, _b, _c;
    return ((_b = (_a = INIT_ARGS_DESCRIPTION[key]) === null || _a === void 0 ? void 0 : _a.longDescription) !== null && _b !== void 0 ? _b : (_c = INIT_ARGS_DESCRIPTION[key]) === null || _c === void 0 ? void 0 : _c.shortDescription);
}
exports.getInitArgsLongDescription = getInitArgsLongDescription;
/**
 * Try to get a question form, falling back to the description
 * @param key
 * @returns
 */
function getInitArgsQuestion(key) {
    var _a, _b, _c, _d, _e;
    return ((_d = (_b = (_a = INIT_ARGS_DESCRIPTION[key]) === null || _a === void 0 ? void 0 : _a.question) !== null && _b !== void 0 ? _b : (_c = INIT_ARGS_DESCRIPTION[key]) === null || _c === void 0 ? void 0 : _c.longDescription) !== null && _d !== void 0 ? _d : (_e = INIT_ARGS_DESCRIPTION[key]) === null || _e === void 0 ? void 0 : _e.shortDescription);
}
exports.getInitArgsQuestion = getInitArgsQuestion;
/**
 * Get the possible choices for an arg
 * @param key
 * @returns
 */
function getInitArgsChoices(key) {
    var _a;
    return (_a = INIT_ARGS_DESCRIPTION[key]) === null || _a === void 0 ? void 0 : _a.choices;
}
exports.getInitArgsChoices = getInitArgsChoices;
/**
 * Get a `opt` object for use with the `yargs` library.
 * If no choices are specified, assume it's freeform string input
 * All options use "" as the default, unless overridden
 * @param key
 * @param defaultOverride
 * @returns
 */
function getYargsOption(key, defaultOverride) {
    const arg = lang_utils_1.ensure(INIT_ARGS_DESCRIPTION[key]);
    return !arg.choices
        ? {
            describe: lang_utils_1.ensure(getInitArgsLongDescription(key)),
            string: true,
            default: defaultOverride !== null && defaultOverride !== void 0 ? defaultOverride : "",
        }
        : {
            describe: lang_utils_1.ensure(getInitArgsLongDescription(key)),
            choices: ["", ...lang_utils_1.ensure(getInitArgsChoices(key))],
            default: defaultOverride !== null && defaultOverride !== void 0 ? defaultOverride : "",
        };
}
exports.getYargsOption = getYargsOption;
