"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeVersion = exports.isCallWithoutArguments = exports.isCallIgnoreArguments = exports.makeMemberExpression = exports.memberExpressionMatch = exports.tryExtractPropertyNameOfMemberExpression = exports.makeShowCall = exports.makeShowCallCallee = exports.parseFromJsxExpression = exports.parseJSXExpressionOrContainerAsNodeList = exports.isJsxElementOrFragment = exports.helperObject = void 0;
const babel = __importStar(require("@babel/core"));
const parser = __importStar(require("@babel/parser"));
const traverse_1 = __importDefault(require("@babel/traverse"));
const L = __importStar(require("lodash"));
const cloneDeepWithHook_1 = require("./cloneDeepWithHook");
const common_1 = require("./common");
const utils_1 = require("./utils");
exports.helperObject = "rh";
const tryGetNodeIdFromAttr = (attr) => {
    if (attr.type === "JSXAttribute") {
        if (utils_1.isAttribute(attr, "className") && attr.value) {
            let nodeId = undefined;
            traverse_1.default(attr.value, {
                noScope: true,
                CallExpression: function (path) {
                    const member = exports.tryExtractPropertyNameOfMemberExpression(path.node.callee, exports.helperObject);
                    const m = member === null || member === void 0 ? void 0 : member.match(/^cls(.+)$/);
                    if (m) {
                        nodeId = m[1];
                        path.stop();
                    }
                },
            });
            return nodeId;
        }
    }
    else {
        // spread
        if (attr.argument.type === "CallExpression" &&
            attr.argument.callee.type === "MemberExpression") {
            const member = exports.tryExtractPropertyNameOfMemberExpression(attr.argument.callee, exports.helperObject);
            const m = member === null || member === void 0 ? void 0 : member.match(/^props(.+)$/);
            if (m) {
                return m[1];
            }
        }
    }
    return undefined;
};
const parseJsxElement = (n, plasmicId, parent) => {
    const attrs = n.openingElement.attributes.map((attr) => {
        if (attr.type === "JSXAttribute") {
            const name = utils_1.getAttrName(attr);
            common_1.assert(L.isString(name));
            return [
                name,
                attr.value === null ? null : parseNode(attr.value, attr, false),
            ];
        }
        else {
            // spreador
            return parseNode(attr.argument, attr, false);
        }
    });
    const children = parseChildren(n);
    return {
        attrs,
        children,
        rawNode: n,
        rawParent: parent,
        nameInId: plasmicId,
    };
};
const tryParseAsPlasmicJsxElement = (jsx, parent) => {
    let nodeId = undefined;
    for (const attr of jsx.openingElement.attributes) {
        const curNodeId = tryGetNodeIdFromAttr(attr);
        if (curNodeId) {
            if (nodeId) {
                // The id in className and spreador must match.
                common_1.assert(nodeId === curNodeId);
            }
            nodeId = curNodeId;
        }
    }
    return nodeId ? parseJsxElement(jsx, nodeId, parent) : undefined;
};
exports.isJsxElementOrFragment = (n) => {
    return n.type === "JSXElement" || n.type === "JSXFragment";
};
const parseChildren = (n) => {
    const nodesList = [];
    n.children.forEach((child) => {
        if (child.type === "JSXText") {
            const text = child.value;
            if (text !== undefined) {
                const trimmed = text.trim();
                if (trimmed) {
                    nodesList.push({ type: "text", rawNode: child, value: trimmed });
                }
            }
        }
        else {
            nodesList.push(parseNode(child, n, true));
        }
    });
    return nodesList;
};
const parseNode = (n, parent, forceFragmentAsOneNode) => {
    let node = null;
    if (n.type === "JSXExpressionContainer") {
        // Always unwrap the expression container
        node = parseNode(n.expression, n, forceFragmentAsOneNode);
    }
    else if (n.type === "JSXSpreadChild") {
        node = parseAsOneNode(n.expression, n);
    }
    else if (n.type === "JSXFragment") {
        node = forceFragmentAsOneNode
            ? parseAsOneNode(n, parent)
            : {
                type: "jsx-fragment",
                children: parseChildren(n),
                rawNode: n,
            };
    }
    else {
        node = parseAsOneNode(n, parent);
    }
    node.rawNode = n;
    return node;
};
const parseAsOneNode = (n, parent) => {
    if (n.type === "JSXEmptyExpression") {
        return {
            type: "opaque",
            rawNode: n,
        };
    }
    if (n.type === "StringLiteral") {
        return {
            type: "string-lit",
            value: n.value,
            rawNode: n,
        };
    }
    if (n.type === "CallExpression") {
        const callee = exports.tryExtractPropertyNameOfMemberExpression(n.callee, exports.helperObject);
        const m = callee === null || callee === void 0 ? void 0 : callee.match(/^childStr(.+)$/);
        if (m) {
            return { type: "child-str-call", plasmicId: common_1.ensure(m[1]), rawNode: n };
        }
    }
    // Need to handle this case specially since traverse doesn't visit n itself.
    if (n.type === "JSXElement") {
        const jsxElement = tryParseAsPlasmicJsxElement(n, parent);
        if (jsxElement) {
            return {
                type: "tag-or-component",
                jsxElement,
                rawNode: n,
                secondaryNodes: [],
            };
        }
    }
    const jsxElements = [];
    traverse_1.default(n, {
        noScope: true,
        JSXElement: function (path) {
            const jsxElement = tryParseAsPlasmicJsxElement(path.node, path.parent);
            if (jsxElement) {
                jsxElements.push(jsxElement);
                path.skip();
            }
        },
    });
    return jsxElements.length > 0
        ? {
            type: "tag-or-component",
            jsxElement: jsxElements[0],
            rawNode: n,
            secondaryNodes: jsxElements.slice(1).map((elt) => ({
                type: "tag-or-component",
                jsxElement: elt,
                rawNode: elt.rawParent && elt.rawParent.type === "LogicalExpression"
                    ? elt.rawParent
                    : elt.rawNode,
                secondaryNodes: [],
            })),
        }
        : {
            type: "opaque",
            rawNode: n,
        };
};
exports.parseJSXExpressionOrContainerAsNodeList = (expr) => { };
exports.parseFromJsxExpression = (input) => {
    const ast = parser.parseExpression(input, {
        strictMode: false,
        plugins: ["jsx", "typescript"],
    });
    return parseNode(ast, undefined, true);
};
// Given an AST, collect all JSX nodes into r, which index the nodes by
// nameInId.
const findNodes = (node, tags, secondaryTags) => {
    if (!node) {
        return;
    }
    if (node.type === "tag-or-component") {
        tags.set(node.jsxElement.nameInId, node);
        node.jsxElement.attrs.forEach((attr) => {
            if (!L.isArray(attr)) {
                findNodes(attr, tags, secondaryTags);
            }
            else {
                findNodes(attr[1], tags, secondaryTags);
            }
        });
        node.jsxElement.children.forEach((c) => {
            findNodes(c, tags, secondaryTags);
        });
        node.secondaryNodes.forEach((c) => findNodes(c, tags, secondaryTags));
        node.secondaryNodes.forEach((c) => secondaryTags.set(c.jsxElement.nameInId, c));
    }
    else if (node.type === "jsx-fragment") {
        node.children.forEach((child) => findNodes(child, tags, secondaryTags));
    }
};
exports.makeShowCallCallee = (nameInId) => `${exports.helperObject}.show${nameInId}`;
exports.makeShowCall = (nameInId) => `${exports.makeShowCallCallee(nameInId)}()`;
exports.tryExtractPropertyNameOfMemberExpression = (callee, object) => {
    if (callee.type !== "MemberExpression") {
        return undefined;
    }
    if (callee.object.type === "Identifier" &&
        callee.object.name === object &&
        callee.property.type === "Identifier") {
        return callee.property.name;
    }
    return undefined;
};
exports.memberExpressionMatch = (node, object, member) => {
    if (node.type !== "MemberExpression") {
        return false;
    }
    return (node.object.type === "Identifier" &&
        node.object.name === object &&
        node.property.type === "Identifier" &&
        node.property.name === member);
};
exports.makeMemberExpression = (object, member) => {
    return babel.types.memberExpression(babel.types.identifier(object), babel.types.identifier(member));
};
exports.isCallIgnoreArguments = (call, object, member) => {
    if (call.type !== "CallExpression") {
        return false;
    }
    return exports.memberExpressionMatch(call.callee, object, member);
};
exports.isCallWithoutArguments = (call, object, member) => {
    return (exports.isCallIgnoreArguments(call, object, member) && call.arguments.length === 0);
};
class CodeVersion {
    constructor(rootExpr, 
    // A map from nameInId to uuid
    nameInIdToUuid) {
        this.nameInIdToUuid = nameInIdToUuid;
        // keyed by nameInId, which could be uuid, or name
        this.allTagOrComponents = new Map();
        // keyed by nameInId, which could be uuid, or name
        this.secondaryTagsOrComponents = new Map();
        // keyed by uuid
        this.tagOrComponentsByUuid = new Map();
        this.uuidToNameInId = new Map();
        this.slotArgNameToUuid = new Map();
        this.uuidToSlotArgName = new Map();
        if (L.isString(rootExpr)) {
            this.root = exports.parseFromJsxExpression(rootExpr);
        }
        else {
            this.root = parseNode(rootExpr, undefined, true);
        }
        findNodes(this.root, this.allTagOrComponents, this.secondaryTagsOrComponents);
        this.allTagOrComponents.forEach((n, nameInId) => this.tagOrComponentsByUuid.set(common_1.ensure(this.nameInIdToUuid.get(nameInId)), n));
        this.nameInIdToUuid.forEach((uuid, nameInId) => {
            this.uuidToNameInId.set(uuid, nameInId);
            if (nameInId.startsWith("$slot")) {
                const argName = L.lowerFirst(nameInId.substr(5));
                this.slotArgNameToUuid.set(argName, uuid);
                this.uuidToSlotArgName.set(uuid, argName);
            }
        });
    }
    renameJsxTree(targetCodeVersion) {
        const revisedNameInIdToUuid = new Map(targetCodeVersion.nameInIdToUuid);
        const renamedJsx = cloneDeepWithHook_1.cloneDeepWithHook(this.root.rawNode, (n) => {
            const helperMember = exports.tryExtractPropertyNameOfMemberExpression(n, exports.helperObject);
            if (helperMember) {
                const eventHandlers = [
                    "onMouseUp",
                    "onMouseDown",
                    "onFocus",
                    "onBlur",
                    "onMouseEnter",
                    "onMouseLeave",
                ];
                const regEx = new RegExp(`^(cls|props|show|childStr|${eventHandlers.join("|")})(.+)$`);
                const m = helperMember.match(regEx);
                if (m) {
                    const prefix = m[1];
                    const nameInId = m[2];
                    const curUuid = common_1.ensure(this.nameInIdToUuid.get(nameInId));
                    const newNameInId = targetCodeVersion.findMatchingNameInId({
                        nameInId,
                        uuid: curUuid,
                    });
                    if (!newNameInId) {
                        // node has been deleted in targetCodeVersion. Fine to keep the name,
                        // but need to add this id into the new map.
                        revisedNameInIdToUuid.set(nameInId, curUuid);
                    }
                    else {
                        return exports.makeMemberExpression(exports.helperObject, `${prefix}${newNameInId}`);
                    }
                }
                return undefined;
            }
            const argName = exports.tryExtractPropertyNameOfMemberExpression(n, "args");
            if (argName) {
                const newSlotArgName = targetCodeVersion.findMatchingSlotArgName(argName, this.tryGetSlotArgUuid(argName));
                if (!newSlotArgName) {
                    // Either non slot args, or the arg has been deleted. Keep the name
                }
                else {
                    return exports.makeMemberExpression("args", newSlotArgName);
                }
            }
            return undefined;
        });
        common_1.assert(babel.types.isExpression(renamedJsx));
        return new CodeVersion(renamedJsx, revisedNameInIdToUuid);
    }
    findMatchingNameInId(id) {
        const uuid = this.nameInIdToUuid.get(id.nameInId);
        if (uuid) {
            // nameInId exists - keep the id!
            return id.nameInId;
        }
        // nameInId doesn't exist. Match by uuid
        return this.uuidToNameInId.get(id.uuid);
    }
    findMatchingSlotArgName(argName, uuid) {
        const slotUuid = this.slotArgNameToUuid.get(argName);
        if (slotUuid) {
            // argName exists - keep the name
            return argName;
        }
        if (!uuid) {
            return undefined;
        }
        // Match by UUID
        return this.uuidToSlotArgName.get(uuid);
    }
    // Find a tagOrComponent node whose nameInId matches, or uuid matches.
    // nameInId has higher priority.
    findTagOrComponent(nameInId) {
        return this.allTagOrComponents.get(nameInId);
    }
    tryGetSlotArgUuid(argName) {
        return this.slotArgNameToUuid.get(argName);
    }
    hasShowFuncCall(node) {
        if (node.rawNode === node.jsxElement.rawNode) {
            return false;
        }
        let found = false;
        traverse_1.default(node.rawNode, {
            noScope: true,
            CallExpression: function (path) {
                if (exports.memberExpressionMatch(path.node.callee, exports.helperObject, `show${node.jsxElement.nameInId}`)) {
                    found = true;
                    path.stop();
                }
            },
            JSXElement: function (path) {
                if (path.node === node.jsxElement.rawNode) {
                    path.skip();
                }
            },
        });
        return found;
    }
    hasClassNameIdAttr(node) {
        const matchingAttr = node.jsxElement.rawNode.openingElement.attributes.find((attr) => {
            if (!utils_1.isAttribute(attr, "className")) {
                return false;
            }
            let found = false;
            traverse_1.default(attr, {
                noScope: true,
                MemberExpression: function (path) {
                    found =
                        found ||
                            exports.memberExpressionMatch(path.node, exports.helperObject, `cls${node.jsxElement.nameInId}`);
                    if (found) {
                        path.stop();
                    }
                },
            });
            return found;
        });
        return !!matchingAttr;
    }
    tryGetPropsIdSpreador(node) {
        const matchingAttr = node.jsxElement.rawNode.openingElement.attributes.find((attr) => {
            if (attr.type !== "JSXSpreadAttribute") {
                return false;
            }
            let found = false;
            traverse_1.default(attr, {
                noScope: true,
                MemberExpression: function (path) {
                    found =
                        found ||
                            exports.memberExpressionMatch(path.node, exports.helperObject, `props${node.jsxElement.nameInId}`);
                    if (found) {
                        path.stop();
                    }
                },
            });
            return found;
        });
        return matchingAttr;
    }
    hasPropsIdSpreador(node) {
        return !!this.tryGetPropsIdSpreador(node);
    }
}
exports.CodeVersion = CodeVersion;
